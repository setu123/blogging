package com.square.blogging.service;

import com.square.blogging.exception.UserAlreadyExists;
import com.square.blogging.model.Role;
import com.square.blogging.model.User;
import com.square.blogging.repository.RoleRepository;
import com.square.blogging.repository.UserRepository;
import com.square.blogging.util.ThrowingFunction;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.security.SecureRandom;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
@Transactional
public class UserService {

    private static final Logger log = LoggerFactory.getLogger(UserService.class);
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private RoleRepository roleRepository;
    @Autowired
    private PasswordEncoder passwordEncoder;

    public void createBlogger(User user) throws UserAlreadyExists {
        user.setStatus(User.Status.PENDING);
        //user.setType(User.Type.BLOGGER);
        List<Role> roles = new ArrayList<>();
        roles.add(getRole(Role.RoleName.BLOGGER));
        user.setRoles(roles);
        createUser(user);
    }

    public void createAdminUser(User user) throws UserAlreadyExists {
        user.setStatus(User.Status.APPROVED);
        //user.setType(User.Type.ADMIN);
        List<Role> roles = new ArrayList<>();
        roles.add(getRole(Role.RoleName.ADMIN));
        user.setRoles(roles);
        createUser(user);
    }

    private Role getRole(Role.RoleName name){
        Optional<Role> existingRole = roleRepository.findByName(name);
        log.info("Role with name " + name + ": " + existingRole.isEmpty());
        Role newRole = new Role(name);
        log.info("newRole: " + newRole.getName());

        Role toReturn = roleRepository.findByName(name)
        .orElseGet(() -> persistAndGet(name));
        log.info("toReturn: " + toReturn);
        return toReturn;
    }

    private Role persistAndGet(Role.RoleName name){
        log.info("Going to persist " + name);
        return roleRepository.save(new Role(name));
    }

    private void createUser(User user) throws UserAlreadyExists {
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        try {
            Mono.justOrEmpty(userRepository.save(user));
        }catch (DataIntegrityViolationException dve){
            throw new UserAlreadyExists();
        }catch (Exception ex){
            log.error("Unknon error: " + ex.getMessage());
            throw ex;
        }
    }

    public void updateUserStatus(long id, User.Status status){
        Mono.justOrEmpty(userRepository.findById(id).map(usr -> {
            usr.setStatus(status);
            return userRepository.save(usr);
        }));
    }

    public Flux<User> getAdmins(){
        return findUserByRole(Role.RoleName.ADMIN);
    }

    public Flux<User> getBloggers(){
        return findUserByRole(Role.RoleName.BLOGGER);
    }

    private Flux<User> findUserByRole(Role.RoleName name){
        return Flux.fromIterable(userRepository.findAllByRolesName(name));
        //return Flux.fromIterable(userRepository.findAllByRolesIn(List.of(role)));
    }

    /**
    private Flux<User> findUserByRole(Role role){
        return Flux.fromIterable(userRepository.findAllByRolesIn(List.of(role)));
    }
     */

    public Mono<User> findById(long id){
        return Mono.justOrEmpty(userRepository.findById(id));
    }

    public void initAdminCheck(){
        getAdmins().hasElements().subscribe(has -> {
            if(!has)
                generateAdmin();
            else{
                log.info("System contains admin user. No admin user would be generated by the system automatically");
            }
        });
    }

    private void generateAdmin(){
        getRandomSpecialChars().map(Objects::toString)
                .collect(Collectors.collectingAndThen(Collectors.joining(),
                        ThrowingFunction.unchecked(this::constructAndGenerate)));
    }

    private User constructAndGenerate(String password) throws UserAlreadyExists {
        User user = new User();
        user.setUsername("user");
        user.setPassword(password);
        createAdminUser(user);
        System.out.printf("Using generated security password: %s%n", password);
        return user;
    }

    public Stream<Character> getRandomSpecialChars() {
        return new SecureRandom().ints(8, 65, 122)
                .mapToObj(data -> (char) data);
    }
}
